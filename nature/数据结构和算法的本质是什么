数据结构和算法的本质是什么
数据结构和算法的本质是为了利用机器来实现人们想要的逻辑，并以此来降低重复性劳动力的成本，主要包含信息的存储、计算、传递三大作用，也是互联网大产业发展的根基。以通信为例，我们来阐述其价值
1）很久很久以前，传递成本很高，人们传递信息需要走门串巷，如果我想跟暗恋对象表白，那我就需要走很久的路，去她家里告诉她，或者借着她亲哥来我家串门时，委托她亲哥回家告诉她明天晚上7点，在村里那颗老树下约会
2）后来有了鸽子，减少了传递成本，人们可以不用徒步去她家了，可以通过飞鸽传书借助鸽子来传递信息
3）后来有了计算器，减少了计算成本，大家不用口算大数，或者硬生生用捉襟见肘的十个手指来算，直接用计算器，简单又准确
3）后来有了硬盘，减少了存储成本，以前写情书，写在纸上又扔掉，攒了一大箩筐的草稿，现在只需要敲键盘，可以存几亿封情书，还可以随意修改不浪费纸张
4）后来有了U盘，减少了传递（沟通也是一种更加深度的传递）成本，你想要动作片，来我家拿U盘即可，你自己看，我就不跟你细聊了
那么我们对所有的数据都用数组来存储是不是可以？
当然也可以，但是效率很低，比如单向链表类数据用数组来存储，也是可以的，单向链表有next指针，数组有index，存储空间复杂度差不多，但是如果我要删除其中一个元素，数组就会先得很臃肿而低效
，因为数组是连续性存储空间，删除一个元素，需要把右边的元素都通通往前做一遍，和删除元素的左边元素拼接上，再形成连续性存储空间，如果是链表的话，就很高效，删除这个节点就可以了，右边节点不用挪
因此，为了提高存储、计算、传递效率，我们需要不同的数据结构来适配不同的逻辑实现，
比如为了提高存储效率，我们可以把复杂长串的字母数据用数字-字母映射表来转存为数字，存储大小大幅下降，最后再通过映射表反向翻译即可
比如为了提高计算效率，我们可以用int代替long来计算常规数字的计算场景
比如为了提高传递效率，谷歌设计了protobuffer数据结构，把数据全部编码为整型数字后传输到目的地，再利用protobuffer翻译回源数据，大幅度减少了通信成本

刷leetcode的最高境界是通过刷题加深我们对常见逻辑和更匹配的数据结构的理解，如果利用现有数据结构来实现解题逻辑，时间复杂度和空间复杂度都很高，那怎么办？
一种办法是使用更加高效的数据结构，另一种办法是我们转换解题逻辑，这样就打开了视野格局，在更高层面上审视问题，现有数据结构也能更高效解题了
题目是多种多样，无穷无尽的，但是数据结构相对来说比较有限，我们来研究下不同数据结构的优劣势，适配的本质场景，进而可以帮助我们打开更多样、更高效的解题思路

链表：查找元素效率低(o(n))，邻域查找效率高（查找next元素），增删改元素效率高(o(1))，内存利用效率高（可以用碎片内存），可动态拓展
数组：查找效率高（o(1)）, 邻域查找效率高，增删改查元素效率低(o(n))，内存利用效率低，不支持动态拓展
排序数组：数组的一种特殊方式，比如用来做高效的二分查找，时间复杂度log(n)，比数组查找效率更高
树：对树形结构效率更高，数组只是一维的
哈希表：查找效率更高，比排序数组还要高，o（1）时间复杂度
映射表：kv数据库，也可以用两个数组来解决，但是两个数组的效率低；
int：单个整型元素，也可以用一个元素的数组来存储，但是效率低
堆：
栈：后进先出LIFO，底层可以用数组实现也可以用链表实现，同时栈也更方便动态维护，如果用链表方式的增删改效率高
队列：先进先出FIFO，底层可以用数组实现也可以用链表实现
二进制：只有0/1值，很简单，可以用于快速幂，快速乘等方法
